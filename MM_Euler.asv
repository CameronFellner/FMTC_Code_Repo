function [obj_follower, obj_leader] = MM_Euler(a, beta, disp_results)    
    % Stock Price
    sigma = 1;
    S0 = 100;
    
    % Arrival Probabilities ~ Poission(Î»)
    lambda_a = 10;
    lambda_b = 10; 
    
    % Inventory
    qmax = 10;
    qmin = -qmax;
    
    % Noise terms
    sigma_Z = 0; 

    
    kappa = 2; % Fill probability sensitivity 
    eta = 0.01; % TICK SIZE
    % a is given (a = 0) - Reference levels to ask
    b = a; % Reference level to bid
    % beta is given (beta = 0.05) - Inventory level's impact on quoting
    
    % Penalties
    phi = 0.01;
    gamma = 0.03;
    
    % All possible inventory levels 
    all_inventories = qmax:-1:qmin-1;
    
    % Time scale
    T = 1;
    Nt = 1000; % Number of steps
    sims = 10000; % Number of monte carlo simulations
    dt = T/Nt; % Time step size
    euler_steps = 1000000; % Euler steps
    time = linspace(0, T, Nt+1); % Time axis
    
    
    % Initialize arrays
    X = zeros(sims, Nt+1); % Cash
    X_tilde = zeros(sims, Nt+1); % Cash
    Q = zeros(sims, Nt+1); % Inventory
    Q_tilde = zeros(sims, Nt+1); % Competitors Inventory
    S = zeros(sims, Nt+1); % Stock price path
    S(:,1) = S0; % Start stock at S0
    Z = zeros(sims, Nt+1); % Noise terms
    intQ = zeros(sims, 1);  % Q Integral
    intQ_tilde = zeros(sims, 1);  % I dont know

    % Bid ask qouotes of us and the competitor
    deltas_a = zeros(sims, Nt+1);
    deltas_b = zeros(sims, Nt+1);
    tildes_a = zeros(sims, Nt+1);
    tildes_b = zeros(sims, Nt+1);
    
    % Arrival of the asks and bids
    arrivaltimes_a = zeros(sims, Nt+1);
    arrivaltimes_b = zeros(sims, Nt+1);
    
    
    % Run Euler scheme to calculate g as a function of time step and inventory
    % g(t,q)
    g = euler_scheme(euler_steps, T, qmax, qmin, a, b, gamma, beta, kappa, phi, lambda_a, lambda_b);
    
    % Round all_inventories to the cent
    all_inventories_list = round(all_inventories, 2);
    
    % Main simulation loop
    % For each time step (i)
    for i = 1:Nt
        t = time(i);
        
        % Get current g values for this time step
        gt_all_q = g(round(i*(euler_steps/Nt)), :);
    
        % Pre-allocate space for G, G up and G down
        G = zeros(sims, 1);
        G_down = zeros(sims, 1);
        G_up = zeros(sims, 1);
        
        % For each sumlation (sim)
        for sim = 1:sims
            % Get inventory level 
            q = Q(sim,i);
            % Get G for this inventory level
            [~, idx] = min(abs(all_inventories_list - q)); % Index of current inventory level
            G(sim) = gt_all_q(idx);
            
            % If inventory is not empty get G Down, for when we fill an ask 
            if q ~= qmin
                [~, idx_down] = min(abs(all_inventories_list - (q-1)));
                G_down(sim) = gt_all_q(idx_down);
            end
            
            % If inventory is not full get G Up, for when we fill a bid
            if q ~= qmax
                [~, idx_up] = min(abs(all_inventories_list - (q+1)));
                G_up(sim) = gt_all_q(idx_up);
            end
        end
        
        % Calculate deltas
        [delta_a, delta_b] = calculate_deltas_euler(t, Q(:,i), Q_tilde(:,i), Z(:,i), G, G_down, G_up, ...
                             kappa, a, b, beta, true);
        % Save deltas
        deltas_a(:, i) = delta_a;
        deltas_b(:, i) = delta_b;
        
        % Update Z and S (Brownian motions)
        Z(:,i+1) = Z(:,i) + sigma_Z * sqrt(dt) * randn(sims, 1);
        S(:,i+1) = S(:,i) + sigma * sqrt(dt) * randn(sims, 1);
        
        % Simulate order arrivals
        [arrival_a, arrival_b] = get_arrival(sims, dt, lambda_a, lambda_b);
        arrivaltimes_a(:,i) = arrival_a * t;
        arrivaltimes_b(:,i) = arrival_b * t;
        
        % Calculate fill probabilities
        fill_a = rand(sims, 1);
        fill_b = rand(sims, 1);
        
        % Get competitor bid ask quotes
        delta_tilde_a = a - beta * Q_tilde(:,i) - Z(:,i);
        delta_tilde_b = b + beta * Q_tilde(:,i) + Z(:,i);
        tildes_a(:,i) = delta_tilde_a;
        tildes_b(:,i) = delta_tilde_b;
        
        % Calculate prob of filling orders and and respective binary operator 
        prob_a = min(exp(-kappa*(delta_a - delta_tilde_a)), 1);
        prob_b = min(exp(-kappa*(delta_b - delta_tilde_b)), 1);
        filled_trade_a = (fill_a <= prob_a) & (Q(:,i) ~= (qmin+1));
        filled_trade_b = (fill_b <= prob_b) & (Q(:,i) ~= (qmax-1));
        filled_trade_a_tilde = (fill_a <= 1-prob_a) & (Q_tilde(:,i) ~= (qmin+1));
        filled_trade_b_tilde = (fill_b <= 1-prob_b) & (Q_tilde(:,i) ~= (qmax-1));
        
        % Update inventories
        Q(:,i+1) = Q(:,i) - filled_trade_a.*arrival_a + filled_trade_b.*arrival_b;
        Q_tilde(:,i+1) = Q_tilde(:,i) - (1-filled_trade_a).*arrival_a + (1-filled_trade_b).*arrival_b;
        
        % Update cashes
        X(:,i+1) = X(:,i) + filled_trade_a.*arrival_a.*(S(:,i) + delta_a) ...
                    - filled_trade_b.*arrival_b.*(S(:,i) - delta_b);
        X_tilde(:,i+1) = X_tilde(:,i) + filled_trade_a_tilde.*arrival_a.*(S(:,i) + delta_tilde_a) ...
                    - filled_trade_b_tilde.*arrival_b.*(S(:,i) - delta_tilde_b);

    end
    
    % Calculate final PnL and objectives
    pnl_euler = X(:,end) + Q(:,end).*(S(:,end) + (a-b)/2 - beta*Q_tilde(:,end) - Z(:,end));
    for s = 1:sims
        intQ(s) = sum(Q(s,:).^2)/Nt;
    end
    obj = pnl_euler - a*Q(:,end).^2 - phi*intQ;

    pnl_euler_tilde = X_tilde(:,end) + Q_tilde(:,end).*(S(:,end) + (a-b)/2 - beta*Q_tilde(:,end) - Z(:,end));
    for s = 1:sims
        intQ_tilde(s) = sum(Q_tilde(s,:).^2)/Nt;
    end
    obj_tilde = pnl_euler_tilde - a*Q_tilde(:,end).^2 - phi*intQ_tilde;

    obj_follower = obj;
    obj_leader  = obj_tilde;

    
    % Display results if desired
    if (disp_results == true)
        % Copy last values for plotting
        deltas_a(:,end) = deltas_a(:,end-1);
        deltas_b(:,end) = deltas_b(:,end-1);
        tildes_a(:,end) = tildes_a(:,end-1);
        tildes_b(:,end) = tildes_b(:,end-1);
        
        % Display results
        fprintf('Reference MM Results');
        fprintf('Terminal Q mean = %.4f\tTerminal Q sd = %.4f\n', mean(Q(:,end)), std(Q(:,end)));
        fprintf('Terminal X mean = %.4f\tTerminal X sd = %.4f\n', mean(X(:,end)), std(X(:,end)));
        fprintf('Terminal PnL mean = %.4f\tTerminal PnL sd = %.4f\n', mean(pnl_euler), std(pnl_euler));
        fprintf('Terminal objective mean = %.4f\tTerminal objective sd = %.4f\n', mean(obj), std(obj));
        
        % Plot results
        nmin = 1;
        nmax = 1000;
        figure;
        subplot(4,2,1);
        plot(time, Q(nmin:nmax,:)');
        hold on;
        plot(time, repmat(qmax,1,length(time)), '--');
        plot(time, repmat(qmin,1,length(time)), '--');
        ylabel('$Q_t$', 'Interpreter', 'latex');
        grid on;
        
        subplot(4,2,2);
        plot(time, Q_tilde(nmin:nmax,:)');
        ylabel('$\tilde{Q}_t$', 'Interpreter', 'latex');
        grid on;
        
        % Plot delta a and tilde delta a
        subplot(4,2,3);
        plot(time, deltas_a(nmin:nmax,:)');
        ylabel('$\delta^{*,a}_t$', 'Interpreter', 'latex');
        grid on;
        alpha(0.3);
        
        subplot(4,2,4);
        plot(time, tildes_a(nmin:nmax,:)');
        ylabel('$\tilde{\delta}^{a}_t$', 'Interpreter', 'latex');
        grid on;
        alpha(0.3);
        
        % Plot delta b and tilde delta b
        subplot(4,2,5);
        plot(time, deltas_b(nmin:nmax,:)');
        ylabel('$\delta^{*,b}_t$', 'Interpreter', 'latex');
        grid on;
        alpha(0.3);
        
        subplot(4,2,6);
        plot(time, tildes_b(nmin:nmax,:)');
        ylabel('$\tilde{\delta}^{b}_t$', 'Interpreter', 'latex');
        grid on;
        alpha(0.3);
        
        % Plot spreads
        subplot(4,2,7);
        plot(time, deltas_a(nmin:nmax,:)' + deltas_b(nmin:nmax,:)');
        xlabel('$t$', 'Interpreter', 'latex');
        ylabel('$\delta^{*,a}_t+\delta^{*,b}_t$', 'Interpreter', 'latex');
        grid on;
        alpha(0.3);
        
        subplot(4,2,8);
        plot(time, tildes_a(nmin:nmax,:)' + tildes_b(nmin:nmax,:)');
        xlabel('$t$', 'Interpreter', 'latex');
        ylabel('$\tilde{\delta}^{a}_t+\tilde{\delta}^{b}_t$', 'Interpreter', 'latex');
        grid on;
        alpha(0.3);
        
        % Adjust layout
        set(gcf, 'Color', 'w'); % White background
        set(gcf, 'Position', [100 100 900 900]); % Set figure size
        
        % Add legends where needed
        subplot(4,2,3);
        legend('Sim 1', 'Sim 2', 'Sim 3', 'Location', 'best');
        
        subplot(4,2,5);
        legend('Sim 1', 'Sim 2', 'Sim 3', 'Location', 'best');
        
        % Tight layout
        h = findobj(gcf, 'type', 'axes');
        set(h, 'FontSize', 12); % Consistent font size
    end
end

function g = euler_scheme(steps, T, qmax, qmin, a, b, gamma, beta, kappa, phi, lambda_a, lambda_b)
    % Initialize variables
    h = T / steps;
    all_inventories = qmax:-1:qmin; 
    g = zeros(steps, length(all_inventories));
    
    % Terminal condition
    for iq = 1:length(all_inventories)
        q = all_inventories(iq);
        g(end, iq) = ((a-b)/2)*q - (gamma-beta/2)*(q^2);
    end
    
    % Time stepping (backward)
    for i = 1:(steps-1)
        for iq = 1:length(all_inventories)
            q = all_inventories(iq);
            
            % Interior points
            if iq ~= 1 && iq ~= length(all_inventories)
                c_star_a = max(1/kappa - g(end-i+1, iq-1) + g(end-i+1, iq), a - beta/2);
                c_star_b = max(1/kappa - g(end-i+1, iq+1) + g(end-i+1, iq), b - beta/2);
                
                g(end-i, iq) = g(end-i+1, iq) + h * ( ...
                    -phi*(q^2) ...
                    + (lambda_a-lambda_b)*beta*q ...
                    + lambda_a*exp(-kappa*(c_star_a + beta/2 - a))*(c_star_a + g(end-i+1,iq-1) - g(end-i+1,iq)) ...
                    + lambda_b*exp(-kappa*(c_star_b + beta/2 - b))*(c_star_b + g(end-i+1,iq+1) - g(end-i+1,iq)));
            
            % Lower boundary (iq == 1)
            elseif iq == 1
                c_star_b = max(1/kappa - g(end-i+1, iq+1) + g(end-i+1, iq), b - beta/2);
                
                g(end-i, iq) = g(end-i+1, iq) + h * ( ...
                    -phi*(q^2) ...
                    + (lambda_a-lambda_b)*beta*q ...
                    + lambda_b*exp(-kappa*(c_star_b + beta/2 - b))*(c_star_b + g(end-i+1,iq+1) - g(end-i+1,iq)));
            
            % Upper boundary (iq == end)
            else
                c_star_a = max(1/kappa - g(end-i+1, iq-1) + g(end-i+1, iq), a - beta/2);
                
                g(end-i, iq) = g(end-i+1, iq) + h * ( ...
                    -phi*(q^2) ...
                    + (lambda_a-lambda_b)*beta*q ...
                    + lambda_a*exp(-kappa*(c_star_a + beta/2 - a))*(c_star_a + g(end-i+1,iq-1) - g(end-i+1,iq)));
            end
        end
    end
end

function [delta_a, delta_b] = calculate_deltas_euler(t, q, q_tilde, z, gt, gt_q_minus, gt_q_plus, kappa, a, b, beta, take_maximum)
    % Calculate c_hat values
    c_hat_a = 1/kappa - gt_q_minus + gt;
    c_hat_b = 1/kappa - gt_q_plus + gt;
    
    % Apply maximum condition if needed
    if take_maximum
        c_a = max(c_hat_a, a - beta/2);
        c_b = max(c_hat_b, b - beta/2);
    else
        c_a = c_hat_a;
        c_b = c_hat_b;
    end
    
    % Calculate final deltas
    delta_a = c_a - beta*q_tilde - z + beta/2;
    delta_b = c_b + beta*q_tilde + z + beta/2;
end

function [arrival_a, arrival_b] = get_arrival(sims, dt, lambda_a, lambda_b)
    % Generate uniform random numbers
    unif_a = rand(sims, 1);
    unif_b = rand(sims, 1);
    
    % Determine arrivals using Poisson process probabilities
    arrival_a = unif_a < (1 - exp(-lambda_a * dt));
    arrival_b = unif_b < (1 - exp(-lambda_b * dt));
    
end

